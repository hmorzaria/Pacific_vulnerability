# Hem Nalini Morzaria Luna
# Vulnerability indices
#based on Jacob et al. 2012 & Morzaria-Luna et al. 2014
#Created July 2015
#Last updated July 2015

#install.packages(c("gdata","tidyr","pipeR","erer","psych","nFactors","tidyr","pipeR","erer","reshape","ggplot2","dplyr","FactoMineR"))
library(psych)
library(nFactors)
library(reshape)
library(ggplot2)
library(dplyr)
library(gdata)
library(data.table)
library(tidyr)
library(pipeR)
library(erer)
library(FactoMineR)


rm(list=ls()) #clean up the space

#list cutom functions
source("E:/Archivos/1Archivos/Articulos/R_functions/pause_function.R")
source("E:/Archivos/1Archivos/Articulos/R_functions/Theta_function.R")

# USER BLOCK: CHECK AND CHANGE OPTIONS HERE  
#_________________________________________________________________________
#set working directories
#this should match the path where your files directories are stored
#note the "/" go in the opposite direction than in Windows explorer

threshold.value = 0.2 #this is the threshold for correlation values

#working space
analysispath="E:/Archivos/1Archivos/Articulos/En preparacion/Vulnerability_GOC_Pacific/Analysis" #put path

setwd(analysispath)

indices.sc = c("population_composition")

#Analysis expects csv files with locations as 1st column and variables as other columns, values in rows
files.index = c("PopComp.csv")


#_________________________________________________________________________

#make list to save results
results.index=list()
#use for debugging
each.index= 1
#for(each.index in 1:length(files.index))
#{
indices.sc[each.index] %>>% 
	(~index.name) 

  #read data

#piped code
#To debug this code, insert (~ browser()) around the pipeline 
#At the browser environment, one only needs to type .
#works with %>>%
#obtain correlation matrix
#get correlation matrix and statistics
X11()

files.index[each.index] %>%
fread(header = T,drop=1) %>>% #eliminate column with row names, needs only data values
  (~ index.data) %>% 
  cor %>>% 
  "correlation matrix" %>>%
  (~ corr.mat) %>>% 
 "correlation matrix" %>>%
  (~ pairs(.)) %>>% {
  no.cols <- ncol(.)
  no.rows <- nrow(.)
  parallel(subject=no.rows,var=no.cols,rep=100,cent=.05) %>% { #scree test
    .$eigen %>% 
     select(qevpea) %>% 
    nScree(eigen(cor(index.data))$values,(.$qevpea)) %>>% {
    	summary (.) #scree test will return number of factors according to different methods
    	plotnScree((.), main=paste("Non Graphical Solutions to Scree Test _",index.name)) 
    }
  }
  } 

pause()
  
# Determine Number of Factors to Extract
   #This code can be use to determine the optimal number of factors, however Jacob et al (2012)
  #recommends using a single factor solution
  # Generally, if the goal is simple and parsimonious description of a correlation 
  # or covariance matrix, the first k principal components 
  # will do a better job than any other k-dimensional solution
  
#save the scree plot as a png file
dev.copy(png, paste(index.name,'.png',sep="")) 
dev.off()

#now take correlation matrix and make data frame

index.data %>% 
	cor %>% 
  as.data.frame %>>%
  (~ corr.mat)%>%
  names %>% 
  as.data.frame %>>%
  (~ names.mat) 
  
names(names.mat) = ("corr_variable")

cbind(names.mat,corr.mat) %>% 
  gather(variable,value,-corr_variable) %>% 
filter(value!=1) %>%
filter(value!=-1) %>%
  group_by(variable) %>%
  summarize(mean_corr = abs(mean(value))) %>% 
  filter(mean_corr > threshold.value) %>>% 
  select(variable) %>>%
  (~selected.vars)

if(nrow(selected.vars) < 4)
  {
    print("Analysis needs at least 4 variables, now running with lower correlation threshold value")
  threshold.value = threshold.value - 0.05
  cbind(names.mat,corr.mat) %>% 
    gather(variable,value,-corr_variable) %>% 
    filter(value!=1) %>%
    filter(value!=-1) %>%
    group_by(variable) %>%
    summarize(mean_corr = abs(mean(value))) %>% 
    filter(mean_corr > threshold.value) %>>% 
    select(variable) %>>%
    (~selected.vars)

  if(nrow(selected.vars) < 4)
     {
     print("Too few variables selected, now running with lower correlation threshold value")
    threshold.value = threshold.value - 0.05
    cbind(names.mat,corr.mat) %>% 
      gather(variable,value,-corr_variable) %>% 
      filter(value!=1) %>%
      filter(value!=-1) %>%
      group_by(variable) %>%
      summarize(mean_corr = abs(mean(value))) %>% 
      filter(mean_corr > threshold.value) %>>% 
      select(variable) %>>%
      (~selected.vars)
    }
}  
  
selected.vars %>>% 
  (variable) %>%
  drop.levels %>>%
  (~good.variables = as.character(.))
  
X11()

  select(index.data,one_of(good.variables))  %>>% 
    (~subset.index.data = as.data.frame(.)) %>>% #subset the original dataframe leaving only variables with highest correlations
cor %>>% #again calculate correlations and scree test
  (~ corr.mat) %>>% 
  "correlation matrix" %>>%
  (~ pairs(.)) %>>% {
    no.cols <- ncol(.)
    no.rows <- nrow(.)
    parallel(subject=no.rows,var=no.cols,rep=100,cent=.05) %>% { #scree test
      .$eigen %>% 
        select(qevpea) %>% 
        nScree(eigen(cor(subset.index.data))$values,(.$qevpea)) %>>% {
          summary (.) #scree test will return number of factors according to different methods
          plotnScree((.), main=paste("Non Graphical Solutions to Scree Test _",index.name)) 
        }
    }
  } 

  print("The result of the scree test should be one")
  pause()
  
#once extra variables have been eliminated
#run single factor solution
#can specify rotate="varimax" in pc
#SS loading is the eigenvalue
# h2is called the communality estimate. Measures the % of variance 
# in an observed variable accounted for by the retained components
# factor.model finds the reproduced correlations and the communalities (the diagonals)
  #Calculate theta coefficient
  
  files.index[each.index] %>%
    fread(header = T) %>% 
    .$V1 %>>% (~rownames(subset.index.data) <- (.))
    
  subset.index.data %>% 
  PCA %>>% 
    (~pca.results)  %>>% 
    (eig) %>% 
    select(eigenvalue) %>%
    max %>% Theta %>>%
     (~ theta.result)
    

results.index = append(index.name,results.index)
results.index = append(results.index, "Selected variables")
results.index = append(results.index, selected.vars)
results.index = append(results.index, "PCA $eig = eigenvalues and variance, $ind$coord = scores, $var$coord = loadings")
results.index = append(results.index, pca.results)
results.index = append(results.index, "Armor's Theta")
results.index = append(results.index, theta.result)

write.list(results.index,paste(index.name,"_pca_results.csv",sep=""))

