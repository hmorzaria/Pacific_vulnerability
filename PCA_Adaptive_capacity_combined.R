# Hem Nalini Morzaria Luna
# Vulnerability indices
#based on Jacob et al. 2012 & Morzaria-Luna et al. 2014
#Created July 2015
#Last updated July 2015

#install.packages(c("data.table","gdata","tidyr","pipeR","erer","psych","nFactors","tidyr","pipeR","erer","reshape","ggplot2","dplyr","FactoMineR"))
library(nFactors)
library(reshape)
library(ggplot2)
library(dplyr)
library(gdata)
library(data.table)
library(tidyr)
library(pipeR)
library(erer)
library(FactoMineR)
library(magrittr)
library(maptools)


rm(list=ls()) #clean up the space

#list cutom functions
#source("E:/Archivos/1Archivos/Articulos/R_functions/pause_function.R")
source("E:/Archivos/1Archivos/Articulos/R_functions/Theta_function.R")

# USER BLOCK: CHECK AND CHANGE OPTIONS HERE  
#_________________________________________________________________________
#set working directories
#this should match the path where your files directories are stored
#note the "/" go in the opposite direction than in Windows explorer

#working space
analysispath="E:/Archivos/1Archivos/Articulos/En preparacion/Vulnerability_GOC_Pacific/Analysis/ResultsINEGI" #'put path
shapepath = "E:/Archivos/SIG/Proyectos/ArcGis/Datos ordenados/Shapes y layers/Archivos_articulos/Vulnerabilidad_pacifico"


setwd(analysispath)

coastal.coding = c("CVE_EDO","CVE_MUN","CVE_LOC")
indices.sc = c("PopulationComposition", "LaborForce", "HousingIndex", "PovertyIndex")

#Analysis expects csv files with locations as 1st column and variables as other columns, values in rows
files.index = c("variablesPopulationComposition.csv","variables_LaborForce.csv","variables_housing_index.csv","variables_poverty_index.csv")

threshold.value = 0.56995 #this is the threshold for correlation values

setwd(shapepath)

crs.geo.wgs <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

coastal.pops.list <- readOGR(".", "pobcloc10cw_50pop_1km_Pacifico_WGS84")  %>% 
	as("data.frame") %>% 
	tbl_df %>% 
	dplyr::select(one_of(coastal.coding), NOM_LOC, NOM_ENT, NOM_MUN, lon_dd, lat_dd) %>%
	mutate_each_(funs(as.character),coastal.coding) %>% 
	mutate_each_(funs(as.numeric),coastal.coding) %>%
	unique(by=c("CVE_EDO","CVE_MUN","CVE_LOC")) %>% #select variables for coding
	unite(IDENTIFIER,CVE_EDO,CVE_MUN,CVE_LOC, sep = "_") %>% 
	dplyr::select(IDENTIFIER)

#_________________________________________________________________________
setwd(analysispath)
#make list to save results
results.index=list()
#use for debugging
#each.index= 1

for(each.index in 1:length(files.index))
{
index.name = indices.sc[each.index]

coastal.pops.list <- files.index[each.index] %>%
	fread(header = T) %>% 
	tbl_df %>%
	setnames(1,"IDENTIFIER") %>% 
	left_join(coastal.pops.list,by=c("IDENTIFIER"))

}
	
#piped code
#To debug this code, insert (~ browser()) around the pipeline 
#At the browser environment, one only needs to type .
#works with %>>%
#obtain correlation matrix
#get correlation matrix and statistics
#X11()

print("Correlations from full set of data")
#pause()

index.data <- coastal.pops.list %>% 
  dplyr::select(-POPCHANGE_90_10,-POPCHANGE_90_00,-POPCHANGE_05_10) %>% #515 final communities
  #eliminate variables with identical correlations to each other and similar concepts
  dplyr::select(-PE_INAC_F,-PE_INAC_M,-PE_INAC,-PHOGJEF_M,-P_12YMAS, -P_15YMAS, -P_18YMAS) %>% 
  dplyr::select(-P_3YMAS_F, -P_5YMAS_F, -P_12YMAS_F, -P_3YMAS_M, -P_5YMAS_M, -P_12YMAS_M, 
  							-P_15YMAS_F, -P_18YMAS_F, -P_15YMAS_M, -P_18YMAS_M, -P_3YMAS,-P_5YMAS) %>% 
  mutate(DEPEND=POB65_MAS+POB0_14) %>% 
  dplyr::select(-POB0_14,-P_60YMAS, -P_60YMAS_M, P_60YMAS_F)  %>%
mutate(P_6A14_M = P_6A11_M + P_8A14_M) %>% 
	mutate(P_6A14_F = P_6A11_F + P_8A14_F) %>% 
  dplyr::select(-P_6A11_M, -P_8A14_M) %>% 
  mutate(P_6A14 = P_6A11 + P_8A14) %>% 
  dplyr::select(-P_6A11, -P_8A14, -GRAPROES_M) %>% 
dplyr::select(-VPH_PISODT, -VPH_C_ELEC, -VPH_AGUADV,-VPH_DRENAJ, -VPH_2YMASD, -VPH_AGUAFV, 
							-TVIVHAB, -VPH_1DOR) %>% 
	dplyr::select(-P15PRI_INM, -P15PRI_INF, -P18YM_PB_M, -P18YM_PB_F, -P15YM_SE_M, -P15YM_SE_F,
								-P15YM_AN_F, -P15YM_AN_M, -GRAPROES_M, -GRAPROES_F) %>% 
dplyr::select(-PE_INAC_F,-POBMAS, -PE_INAC.y, -PE_INAC_M)


corr.mat <- index.data  %>% 
  cor 

no.cols <- corr.mat %>% ncol

no.rows <- corr.mat %>% nrow

 parallel(subject=no.rows,var=no.cols,rep=100,cent=.05) %>% { #scree test
    .$eigen %>% 
     dplyr::select(qevpea) %>% 
    nScree(eigen(cor(index.data))$values,(.$qevpea)) %>>% {
    	summary (.) #scree test will return number of factors according to different methods
    	plotnScree((.), main=paste("Non Graphical Solutions to Scree Test _",index.name)) 
    }
  }
  

# Determine Number of Factors to Extract
   #This code can be use to determine the optimal number of factors, however Jacob et al (2012)
  #recommends using a single factor solution
  # Generally, if the goal is simple and parsimonious description of a correlation 
  # or covariance matrix, the first k principal components 
  # will do a better job than any other k-dimensional solution
  
#save the scree plot as a png file
dev.copy(png, paste(index.name,'.png',sep="")) 
dev.off()

#now take correlation matrix and make data frame

index.data %>% 
	cor %>% 
  as.data.frame %>>%
  (~ corr.mat)%>%
  names %>% 
  as.data.frame %>>%
  (~ names.mat) 
  
names(names.mat) = ("corr_variable")

print("Now removing variables with low correlation values")
#pause()

cbind(names.mat,corr.mat) %>% 
  gather(variable,value,-corr_variable) %>% 
filter(value!=1) %>%
filter(value!=-1) %>%
  group_by(variable) %>%
  summarize(min_corr = abs(min(value))) %>% 
  filter(min_corr > threshold.value) %>% 
  dplyr::select(variable) %>>%
  (~selected.vars)

print(paste("Currently ",nrow(selected.vars)," variables",sep=""))
print(selected.vars)
print("Iteratively change the threshold value and then run the scree plot again")
print("Also eliminate correlated values that are the same concept")




#Calculate scree test
#       
    selected.vars %>>% 
      (variable) %>%
      drop.levels %>>%
      (~good.variables = as.character(.))


#     #pause()
#     
    dplyr::select(index.data,one_of(good.variables))  %>>% 
      (~subset.index.data = as.data.frame(.)) %>% #subset the original dataframe leaving only variables with highest correlations
      cor %>>% #again calculate correlations and scree test
      (~ corr.mat) 
    
  
    corr.mat %>>% 
      (~no.cols <- ncol(.)) %>>% 
      (~no.rows <- nrow(.))
      
    
        parallel(subject=no.rows,var=no.cols,rep=100,cent=.05) %>>% #scree test
          (eigen) %>% 
          .$qevpea %>>% (~qepva)
        
          nScree(eigen(cor(subset.index.data))$values,qepva) %>>% 
          ~ plotnScree((.), main=paste("Non Graphical Solutions to Scree Test _",index.name)) 
            
       
      print("The result of the scree test should be one")
      
    #pause()
    
    #once extra variables have been eliminated
    #run single factor solution
    #can specify rotate="varimax" in pc
    #SS loading is the eigenvalue
    # h2is called the communality estimate. Measures the % of variance 
    # in an observed variable accounted for by the retained components
    # factor.model finds the reproduced correlations and the communalities (the diagonals)
    #Calculate theta coefficient
    
      names.locs <- files.index[each.index] %>%
      fread(header = T) %>% 
      tbl_df %>% 
        dplyr::select(-POPCHANGE_90_10,-POPCHANGE_90_00,-POPCHANGE_05_10) %>% #2559 final communities
      na.omit %>%
      .$V1 
    
    rownames(subset.index.data) <-  names.locs
      
    subset.index.data %>% 
        PCA %>>% 
      (~pca.results)  %>>% 
      (eig) %>% 
      dplyr::select(eigenvalue) %>%
      max %>% Theta %>>%
      (~ theta.result)
    
  


as.data.frame(theta.result) %>>% (~theta.result) 
  names(theta.result) <- "Armor's Theta"
  results.index$SelectedVariables =  selected.vars
  results.index$PCA = "$eig = eigenvalues and variance, $ind$coord = scores, $var$coord = loadings"
  results.index$eigenvalues.variance =  pca.results$eig
  results.index$loadings =  pca.results$var$coord
  results.index$scores =  pca.results$ind$coord
  results.index$Theta =  theta.result
  results.index$names_scores =  row.names(pca.results$ind$coord)

  #save site scores as a separate file
  names(names.locs) = "sites"
  pca.results$ind$coord %>% 
    cbind(names.locs) %>>%
    (~scores.pca)
 
  write.csv(scores.pca,paste(index.name,"_pca_scores.csv",sep=""))

  write.list(results.index,paste(index.name,"_pca_results.csv",sep=""))

